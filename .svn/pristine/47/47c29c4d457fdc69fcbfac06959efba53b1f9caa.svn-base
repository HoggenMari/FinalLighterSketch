import java.io.File;

import javax.swing.JFileChooser;

import Kinect.PaintHand;
import Kinect.SimpleScene;
import SimpleOpenNI.SimpleOpenNI;

import controlP5.ControlEvent;
import controlP5.ControlP5;
import controlP5.RadioButton;
import hypermedia.net.UDP;
import processing.core.PApplet;
import processing.core.PImage;

public class ProcessingMain extends PApplet {

	/**
	 * 
	 * 
	 */
	private static final long serialVersionUID = 1L;

	// Globale Variablen
	final int LED_RES_X = 24;
	final int LED_RES_Y = 24;
	final int RASTER = 5;
	final int PIXEL_SIZE = 8;
	final int BTN_SIZE = 20;
	final int NUMBER_OF_CONTROLLERS = 1;
	final int NUMBER_OF_PORTS_IN_USE = 2;
	final int PORTS_PR_CONTROLLER = 8;
	UDP udp;
	String ip;
	int port;
	LEDScreen ledScreen1;
	ControlP5 cp5;
	JFileChooser fc;
	SimpleOpenNI simpleOpenNi;
	Kinect kinect;
	Skeleton sk;
	int cnt = 0;
	RadioButton r;
	PaintHand kin;
	SimpleOpenNI context;
	SimpleOpenNI context2;
	SimpleScene kin2;
	
	public void setup() {

		fc = new JFileChooser();

		// Kinect initialisieren
		//simpleOpenNi = new SimpleOpenNI(this);
		//kinect = new Kinect(1, simpleOpenNi, this);
		//setup_kinect(simpleOpenNi, this);
		
		//Kinect initialisieren
		kin = new PaintHand(this);
		context = kin.enable();
		
		kin2 = new SimpleScene(this, context2);
		kin2.enable();
		
		// GUI
		size(450, 450);
		background(255, 255, 255);

		cp5 = new ControlP5(this);
		cp5.addButton("LoadImage").setPosition(RASTER, RASTER)
				.setSize(50, BTN_SIZE).setValue(0);

		r = cp5.addRadioButton("radio").setPosition(5, 30).setSize(10, BTN_SIZE)
				.addItem("image", 0).addItem("Depth", 1).addItem("Paint", 2)
				.setColorLabels(0);
		

		// Bild einlesen
		PImage imageFile = loadImage("/Users/mariushoggenmuller/Documents/blau1.jpg");
		imageFile.resize(LED_RES_X, LED_RES_Y);

		// LEDScreen initialisieren
		int image[] = new int[LED_RES_X * LED_RES_Y];
		ledScreen1 = new LEDScreen(LED_RES_X, LED_RES_Y, image);
		ledScreen1.drawImage(imageFile);

		// UDP initialisieren
		udp = new UDP(this, 5026);
		ip = "224.1.1.1";
		port = 5026;

		// Ausgabe
		sendDMX(ledScreen1.getImage());
		drawOnGui();

		
		//sk = new Skeleton(this);
		//sk.skeletonSetup();

	}

	public void draw() {

		// ledScreen1.drawImage(kinect.drawScene());
		// drawOnGui();
		// sendDMX(ledScreen1.getImage());
		/*PImage img = sk.skeletonDraw();
		img.resize(24, 24);
		img = getReversePImage(img);
		ledScreen1.drawImage(img);
		drawOnGui();
		sendDMX(ledScreen1.getImage());*/
		PImage img = kin.draw(context);
		img.resize(24, 24);
		img = getReversePImage(img);
		ledScreen1.drawImage(img);
		drawOnGui();
		sendDMX(ledScreen1.getImage());

	}

	void drawOnGui() {
		for (int ix = 0; ix < LED_RES_X; ix = ix + 1) {
			for (int iy = 0; iy < LED_RES_Y; iy = iy + 1) {
				int rgb = ledScreen1.getImage()[(ix * LED_RES_Y) + iy];
				fill(rgb);
				rect(60 + ix * PIXEL_SIZE, RASTER + iy * PIXEL_SIZE, 8, 8);
				// System.out.println("Pixel: "+ix+"x"+iy+" "+rgb);
			}
		}
	}

	void LoadImage(int theValue) {
		int returnVal = fc.showOpenDialog(this);

		if (returnVal == JFileChooser.APPROVE_OPTION) {
			File file = fc.getSelectedFile();
			// see if it's an image
			// (better to write a function and check for all supported
			// extensions)
			if (file.getName().endsWith("jpg")) {
				// load the image using the given file path
				PImage img = loadImage(file.getPath());
				if (img != null) {
					// size the window and show the image
					img.resize(LED_RES_X, LED_RES_Y);
					ledScreen1.drawImage(img);
					// sendDMX(ledScreen1.getImage());
					drawOnGui();
				}
			} else {
				// just print the contents to the console
				// note: loadStrings can take a Java File Object too
				String lines[] = loadStrings(file);
				for (int i = 0; i < lines.length; i++) {
					println(lines[i]);
				}
			}
		} else {
			println("Open command cancelled by user.");
		}
	}

	public void mouseClicked() {
		int xField = (mouseX - 60) / PIXEL_SIZE;
		int yField = (mouseY - 5) / PIXEL_SIZE;

		if (mouseX > 60 && mouseY > 5 && xField < LED_RES_X && yField < LED_RES_Y) {
			ledScreen1.setPixel(xField, yField, -1);
			sendDMX(ledScreen1.getImage());
			drawOnGui();
			System.out.println(xField + " " + yField);
		}

	}

	void sendDMX(int[] image) {
		// System.out.println("Send");
		byte[] data = new byte[2702];

		data[0] = 'Y';
		data[1] = 'T';
		data[2] = 'K';
		data[3] = 'J';

		for (int controller = 1; controller <= NUMBER_OF_CONTROLLERS; controller++) {
			data[4] = (byte) (controller);
			data[5] = 0;

			data[6] = 0x57;
			data[7] = 0x05;
			int portsInUse = NUMBER_OF_PORTS_IN_USE - (controller - 1)
					* PORTS_PR_CONTROLLER;
			if (portsInUse > PORTS_PR_CONTROLLER) {
				portsInUse = PORTS_PR_CONTROLLER;
			}

			// System.out.println("Ports: " + portsInUse);

			data[8] = (byte) portsInUse;
			data[9] = 0;

			int dataIndex = 10;
			int ix = 0;

			for (int port = 0, channel = 0; port < portsInUse; port++, channel += 2048) {
				data[dataIndex++] = (byte) (channel & 0xff);
				data[dataIndex++] = (byte) ((channel >> 8) & 0xff);

				int ledsOnPort = 96;
				// System.out.println("ledsOnPort: " + ledsOnPort);
				data[dataIndex++] = (byte) ((ledsOnPort * 3) & 0xff);
				data[dataIndex++] = (byte) (((ledsOnPort * 3) >> 8) & 0xff);

				while (ix < (ledsOnPort / LED_RES_Y)
						+ (port * (ledsOnPort / LED_RES_Y))) {
					for (int iy = 0; iy < LED_RES_Y; iy++) {
						// System.out.println("bla");
						setPixel(ix, iy, image, data, dataIndex);
						dataIndex += 3;
					}
					ix++;
					for (int iy = LED_RES_Y - 1; iy >= 0; iy--) {
						// System.out.println("blubb");
						setPixel(ix, iy, image, data, dataIndex);
						dataIndex += 3;
					}
					ix++;
				}
			}
		}

		// Map the Pixels

		udp.send(data, ip, port);

	}

	void setPixel(int ix, int iy, int[] image, byte data[], int dataIndex) {
		if (((ix * LED_RES_Y) + iy) >= image.length) {
			/* do nothing */
		} else {
			int rgb = image[(ix * LED_RES_Y) + iy];

			data[dataIndex + 2] = (byte) (rgb & 0xff);
			data[dataIndex + 1] = (byte) ((rgb >> 8) & 0xff);
			data[dataIndex] = (byte) ((rgb >> 16) & 0xff);

			// System.out.println("Pixel: "+ix+" "+iy+" "+(byte) ((rgb >> 16) &
			// 0xff));
		}
	}

	public PImage getReversePImage(PImage image) {
		PImage reverse = new PImage(image.width, image.height);
		for (int i = 0; i < image.width; i++) {
			for (int j = 0; j < image.height; j++) {
				reverse.set(image.width - 1 - i, j, image.get(i, j));
			}
		}
		return reverse;
	}

	// -----------------------------------------------------------------
	// -----------------------------------------------------------------
	// SimpleOpenNI events

	public void onNewUser(int userId) {
		println("onNewUser - userId: " + userId);
		println("  start pose detection");

		boolean autoCalib = true;
		if (autoCalib )
			context.requestCalibrationSkeleton(userId, true);
		else
			context.startPoseDetection("Psi", userId);
	}

	public void onLostUser(int userId) {
		println("onLostUser - userId: " + userId);
	}

	public void onExitUser(int userId) {
		println("onExitUser - userId: " + userId);
	}

	public void onReEnterUser(int userId) {
		println("onReEnterUser - userId: " + userId);
	}

	public void onStartCalibration(int userId) {
		println("onStartCalibration - userId: " + userId);
	}

	public void onEndCalibration(int userId, boolean successfull) {
		println("onEndCalibration - userId: " + userId + ", successfull: "
				+ successfull);

		if (successfull) {
			println("  User calibrated !!!");
			context.startTrackingSkeleton(userId);
		} else {
			println("  Failed to calibrate user !!!");
			println("  Start pose detection");
			context.startPoseDetection("Psi", userId);
		}
	}

	public void onStartPose(String pose, int userId) {
		println("onStartPose - userId: " + userId + ", pose: " + pose);
		println(" stop pose detection");

		context.stopPoseDetection(userId);
		context.requestCalibrationSkeleton(userId, true);

	}

	public void onEndPose(String pose, int userId) {
		println("onEndPose - userId: " + userId + ", pose: " + pose);
	}
}
