import java.io.File;
import java.util.ArrayList;

import javax.swing.JFileChooser;

import SimpleOpenNI.SimpleOpenNI;
import SimpleOpenNI.SimpleOpenNIConstants;

import controlP5.ControlP5;
import controlP5.RadioButton;
import hypermedia.net.UDP;
import processing.core.PApplet;
import processing.core.PConstants;
import processing.core.PGraphics;
import processing.core.PImage;
import processing.core.PVector;

public class ProcessingMain extends PApplet {

	/**
	 * 
	 * 
	 */
	private static final long serialVersionUID = 1L;

	// Globale Variablen
	final int LED_RES_X = 24;
	final int LED_RES_Y = 24;
	final int RASTER = 5;
	final int PIXEL_SIZE = 8;
	final int BTN_SIZE = 20;
	final int NUMBER_OF_CONTROLLERS = 1;
	final int NUMBER_OF_PORTS_IN_USE = 3;
	final int PORTS_PR_CONTROLLER = 8;
	UDP udp;
	String ip;
	int port;
	LEDScreen ledScreen1;
	ControlP5 cp5;
	JFileChooser fc;
	SimpleOpenNI simpleOpenNi;
	int cnt = 0;
	RadioButton r;
	SimpleOpenNI context;
	SimpleOpenNI context2;
	PGraphics pg;
	KinectSkeleton kinsk;
	KinectSkeleton kinsk2;
	ArrayList<Integer> users = new ArrayList<Integer>();
	boolean autoCalib=true;
	
	PVector jointPosLeft = new PVector();
    PVector posProjLeft = new PVector();
    PVector jointPosRight = new PVector();
    PVector posProjRight = new PVector();



	

	
	public void setup() {
		
		pg = createGraphics(640, 480);

		fc = new JFileChooser();
		
		setupSkeleton();
		
		// GUI
		size(450, 450);
		background(255, 255, 255);

		cp5 = new ControlP5(this);
		cp5.addButton("LoadImage").setPosition(RASTER, RASTER)
				.setSize(50, BTN_SIZE).setValue(0);

		r = cp5.addRadioButton("radio").setPosition(5, 30).setSize(10, BTN_SIZE)
				.addItem("image", 0).addItem("Depth", 1).addItem("Paint", 2)
				.setColorLabels(0);
		

		// Bild einlesen
		PImage imageFile = loadImage("/Users/mariushoggenmuller/Documents/blau1.jpg");
		imageFile.resize(LED_RES_X, LED_RES_Y);

		// LEDScreen initialisieren
		int image[] = new int[LED_RES_X * LED_RES_Y];
		ledScreen1 = new LEDScreen(LED_RES_X, LED_RES_Y, image);
		ledScreen1.drawImage(imageFile);

		// UDP initialisieren
		udp = new UDP(this, 5026);
		ip = "224.1.1.1";
		port = 5026;

		// Ausgabe
		sendDMX(ledScreen1.getImage());
		drawOnGui();

	}

	public void setupSkeleton() {
		context = new SimpleOpenNI(this);
		if(context.enableDepth()==false) {
			System.out.println("Fehler beim initialisieren der Kinect");
		}
		context.enableUser(SimpleOpenNI.SKEL_PROFILE_ALL);		
	}

	public void draw() {
	
	/*PVector[] pv = kinsk.update(SimpleOpenNIConstants.SKEL_LEFT_HAND, context);

	if(kinsk.getUsers()!=0) {
		System.out.println("LEFTHAND "+pv[0]);

	pg.colorMode(HSB);
	  pg.beginDraw(); 
	  if (mousePressed) {
	    pg.filter(DILATE);
	  } else {
	    pg.filter(ERODE);
	  }
	       pg.stroke( frameCount % 256, 255, 255);
	       //System.out.println(frameCount);

		    pg.filter(BLUR);

	  pg.strokeWeight(5);
	 
	  pg.line(pv[0].x, pv[0].y, pv[0].x, pv[0].y);
	  pg.endDraw();
		  
		  PImage img = pg.get(0,0,640,480);
		  
		//PImage img = kin.draw(context);
		image(img,120,5);
		img.resize(24, 24);
		img = getReversePImage(img);
		ledScreen1.drawImage(img);
		drawOnGui();
		sendDMX(ledScreen1.getImage());
	}*/
		
		drawBlur();

	}
	
	void drawBlur() {
		context.update();
		  //image(context.depthImage(),0,0);
		  if(users.size() > 0){//if there are any users
		    for(int user : users){//for each user
		      //context.getCoM(user,pos);//get the xyz pozition
		       if(context.isTrackingSkeleton(user)){
		          //LEFTRIGHT HAND
		          /*context.getJointPositionSkeleton(user,SimpleOpenNI.SKEL_LEFT_HAND,jointPosLeft);
		          context.convertRealWorldToProjective(jointPosLeft, posProjLeft);
		          context.getJointPositionSkeleton(user,SimpleOpenNI.SKEL_RIGHT_HAND,jointPosRight);
		          context.convertRealWorldToProjective(jointPosRight, posProjRight);*/
		          //NEWOLD
		          PVector posProjLeft_old = new PVector();
		          posProjLeft_old.x = posProjLeft.x;
		          posProjLeft_old.y = posProjLeft.y;

		          System.out.println("OLD: " + posProjLeft_old);
		          context.getJointPositionSkeleton(user,SimpleOpenNI.SKEL_LEFT_HAND,jointPosLeft);
		          context.convertRealWorldToProjective(jointPosLeft, posProjLeft);
		          System.out.println("NEW: " + posProjLeft);
		          
		          point(posProjLeft, posProjLeft_old);
		          println(posProjLeft_old + "" + posProjLeft);
		       }    
		    }
		  }
	}
	
	public void point(PVector posProj1, PVector posProj2) {
		  
		  pg.colorMode(HSB);
		  pg.beginDraw(); 

		  pg.filter(BLUR);

		  pg.stroke( frameCount % 256, 255, 255);
		  pg.strokeWeight(10);
		 
		  pg.line((posProj1.x), (posProj1.y), (posProj1.x), (posProj1.y));
		  pg.endDraw();

		  PImage img = pg.get(0, 0, pg.width, pg.height);
		  image(img,120,5);
			img.resize(24, 24);
			img = getReversePImage(img);
			ledScreen1.drawImage(img);
			drawOnGui();
			sendDMX(ledScreen1.getImage());
	}

	void drawOnGui() {
		for (int ix = 0; ix < LED_RES_X; ix = ix + 1) {
			for (int iy = 0; iy < LED_RES_Y; iy = iy + 1) {
				int rgb = ledScreen1.getImage()[(ix * LED_RES_Y) + iy];
				fill(rgb);
				rect(60 + ix * PIXEL_SIZE, RASTER + iy * PIXEL_SIZE, 8, 8);
				// System.out.println("Pixel: "+ix+"x"+iy+" "+rgb);
			}
		}
	}

	void LoadImage(int theValue) {
		int returnVal = fc.showOpenDialog(this);

		if (returnVal == JFileChooser.APPROVE_OPTION) {
			File file = fc.getSelectedFile();
			// see if it's an image
			// (better to write a function and check for all supported
			// extensions)
			if (file.getName().endsWith("jpg")) {
				// load the image using the given file path
				PImage img = loadImage(file.getPath());
				if (img != null) {
					// size the window and show the image
					img.resize(LED_RES_X, LED_RES_Y);
					ledScreen1.drawImage(img);
					// sendDMX(ledScreen1.getImage());
					drawOnGui();
				}
			} else {
				// just print the contents to the console
				// note: loadStrings can take a Java File Object too
				String lines[] = loadStrings(file);
				for (int i = 0; i < lines.length; i++) {
					println(lines[i]);
				}
			}
		} else {
			println("Open command cancelled by user.");
		}
	}

	public void mouseClicked() {
		int xField = (mouseX - 60) / PIXEL_SIZE;
		int yField = (mouseY - 5) / PIXEL_SIZE;

		if (mouseX > 60 && mouseY > 5 && xField < LED_RES_X && yField < LED_RES_Y) {
			ledScreen1.setPixel(xField, yField, -1);
			sendDMX(ledScreen1.getImage());
			drawOnGui();
			System.out.println(xField + " " + yField);
		}

	}

	void sendDMX(int[] image) {
		// System.out.println("Send");
		byte[] data = new byte[2702];

		data[0] = 'Y';
		data[1] = 'T';
		data[2] = 'K';
		data[3] = 'J';

		for (int controller = 1; controller <= NUMBER_OF_CONTROLLERS; controller++) {
			data[4] = (byte) (controller);
			data[5] = 0;

			data[6] = 0x57;
			data[7] = 0x05;
			int portsInUse = NUMBER_OF_PORTS_IN_USE - (controller - 1)
					* PORTS_PR_CONTROLLER;
			if (portsInUse > PORTS_PR_CONTROLLER) {
				portsInUse = PORTS_PR_CONTROLLER;
			}

			// System.out.println("Ports: " + portsInUse);

			data[8] = (byte) portsInUse;
			data[9] = 0;

			int dataIndex = 10;
			int ix = 0;

			for (int port = 0, channel = 0; port < portsInUse; port++, channel += 2048) {
				data[dataIndex++] = (byte) (channel & 0xff);
				data[dataIndex++] = (byte) ((channel >> 8) & 0xff);

				int ledsOnPort = 96;
				// System.out.println("ledsOnPort: " + ledsOnPort);
				data[dataIndex++] = (byte) ((ledsOnPort * 3) & 0xff);
				data[dataIndex++] = (byte) (((ledsOnPort * 3) >> 8) & 0xff);

				while (ix < (ledsOnPort / LED_RES_Y)
						+ (port * (ledsOnPort / LED_RES_Y))) {
					for (int iy = 0; iy < LED_RES_Y; iy++) {
						// System.out.println("bla");
						setPixel(ix, iy, image, data, dataIndex);
						dataIndex += 3;
					}
					ix++;
					for (int iy = LED_RES_Y - 1; iy >= 0; iy--) {
						// System.out.println("blubb");
						setPixel(ix, iy, image, data, dataIndex);
						dataIndex += 3;
					}
					ix++;
				}
			}
		}

		// Map the Pixels
		udp.send(data, ip, port);

	}

	void setPixel(int ix, int iy, int[] image, byte data[], int dataIndex) {
		if (((ix * LED_RES_Y) + iy) <= image.length) {
			int rgb = image[(ix * LED_RES_Y) + iy];

			data[dataIndex + 2] = (byte) (rgb & 0xff);
			data[dataIndex + 1] = (byte) ((rgb >> 8) & 0xff);
			data[dataIndex] = (byte) ((rgb >> 16) & 0xff);

			// System.out.println("Pixel: "+ix+" "+iy+" "+(byte) ((rgb >> 16) &
			// 0xff));
		}
	}

	public PImage getReversePImage(PImage image) {
		PImage reverse = new PImage(image.width, image.height);
		for (int i = 0; i < image.width; i++) {
			for (int j = 0; j < image.height; j++) {
				reverse.set(image.width - 1 - i, j, image.get(i, j));
			}
		}
		return reverse;
	}
	
	

	// -----------------------------------------------------------------
	// SimpleOpenNI events
	public void onNewUser(int userId){
	  println("detected" + userId);
	  users.add(userId);//a new user was detected add the id to the list
	    if(autoCalib)
	    context.requestCalibrationSkeleton(userId,true);
	  else    
	    context.startPoseDetection("Psi",userId);
	}
	public void onLostUser(int userId){
	  println("lost: " + userId);
	  //not 100% sure if users.remove(userId) will remove the element with value userId or the element at index userId
	  users.remove((Integer)userId);//user was lost, remove the id from the list
	}
	public void onExitUser(int userId)
	{
	  println("onExitUser - userId: " + userId);
	}

	public void onReEnterUser(int userId)
	{
	  println("onReEnterUser - userId: " + userId);
	}

	public void onStartCalibration(int userId)
	{
	  println("onStartCalibration - userId: " + userId);
	}

	public void onEndCalibration(int userId, boolean successfull)
	{
	  println("onEndCalibration - userId: " + userId + ", successfull: " + successfull);
	  
	  if (successfull) 
	  { 
	    println("  User calibrated !!!");
	    context.startTrackingSkeleton(userId); 
	  } 
	  else 
	  { 
	    println("  Failed to calibrate user !!!");
	    println("  Start pose detection");
	    context.startPoseDetection("Psi",userId);
	  }
	}

	public void onStartPose(String pose,int userId)
	{
	  println("onStartPose - userId: " + userId + ", pose: " + pose);
	  println(" stop pose detection");
	  
	  context.stopPoseDetection(userId); 
	  context.requestCalibrationSkeleton(userId, true);
	 
	}

	public void onEndPose(String pose,int userId)
	{
	  println("onEndPose - userId: " + userId + ", pose: " + pose);
	}
}
